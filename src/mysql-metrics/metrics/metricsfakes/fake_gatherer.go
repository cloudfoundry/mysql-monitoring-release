// Code generated by counterfeiter. DO NOT EDIT.
package metricsfakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry/mysql-metrics/metrics"
)

type FakeGatherer struct {
	BrokerStatsStub        func() (map[string]string, error)
	brokerStatsMutex       sync.RWMutex
	brokerStatsArgsForCall []struct {
	}
	brokerStatsReturns struct {
		result1 map[string]string
		result2 error
	}
	brokerStatsReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	CPUStatsStub        func() (map[string]string, error)
	cPUStatsMutex       sync.RWMutex
	cPUStatsArgsForCall []struct {
	}
	cPUStatsReturns struct {
		result1 map[string]string
		result2 error
	}
	cPUStatsReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	DatabaseMetadataStub        func() (map[string]string, map[string]string, error)
	databaseMetadataMutex       sync.RWMutex
	databaseMetadataArgsForCall []struct {
	}
	databaseMetadataReturns struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}
	databaseMetadataReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}
	DiskStatsStub        func() (map[string]string, error)
	diskStatsMutex       sync.RWMutex
	diskStatsArgsForCall []struct {
	}
	diskStatsReturns struct {
		result1 map[string]string
		result2 error
	}
	diskStatsReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	FindLastBackupTimestampStub        func() (time.Time, error)
	findLastBackupTimestampMutex       sync.RWMutex
	findLastBackupTimestampArgsForCall []struct {
	}
	findLastBackupTimestampReturns struct {
		result1 time.Time
		result2 error
	}
	findLastBackupTimestampReturnsOnCall map[int]struct {
		result1 time.Time
		result2 error
	}
	FollowerMetadataStub        func() (map[string]string, map[string]string, error)
	followerMetadataMutex       sync.RWMutex
	followerMetadataArgsForCall []struct {
	}
	followerMetadataReturns struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}
	followerMetadataReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}
	IsDatabaseAvailableStub        func() bool
	isDatabaseAvailableMutex       sync.RWMutex
	isDatabaseAvailableArgsForCall []struct {
	}
	isDatabaseAvailableReturns struct {
		result1 bool
	}
	isDatabaseAvailableReturnsOnCall map[int]struct {
		result1 bool
	}
	IsDatabaseFollowerStub        func() (bool, error)
	isDatabaseFollowerMutex       sync.RWMutex
	isDatabaseFollowerArgsForCall []struct {
	}
	isDatabaseFollowerReturns struct {
		result1 bool
		result2 error
	}
	isDatabaseFollowerReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGatherer) BrokerStats() (map[string]string, error) {
	fake.brokerStatsMutex.Lock()
	ret, specificReturn := fake.brokerStatsReturnsOnCall[len(fake.brokerStatsArgsForCall)]
	fake.brokerStatsArgsForCall = append(fake.brokerStatsArgsForCall, struct {
	}{})
	stub := fake.BrokerStatsStub
	fakeReturns := fake.brokerStatsReturns
	fake.recordInvocation("BrokerStats", []interface{}{})
	fake.brokerStatsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGatherer) BrokerStatsCallCount() int {
	fake.brokerStatsMutex.RLock()
	defer fake.brokerStatsMutex.RUnlock()
	return len(fake.brokerStatsArgsForCall)
}

func (fake *FakeGatherer) BrokerStatsCalls(stub func() (map[string]string, error)) {
	fake.brokerStatsMutex.Lock()
	defer fake.brokerStatsMutex.Unlock()
	fake.BrokerStatsStub = stub
}

func (fake *FakeGatherer) BrokerStatsReturns(result1 map[string]string, result2 error) {
	fake.brokerStatsMutex.Lock()
	defer fake.brokerStatsMutex.Unlock()
	fake.BrokerStatsStub = nil
	fake.brokerStatsReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) BrokerStatsReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.brokerStatsMutex.Lock()
	defer fake.brokerStatsMutex.Unlock()
	fake.BrokerStatsStub = nil
	if fake.brokerStatsReturnsOnCall == nil {
		fake.brokerStatsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.brokerStatsReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) CPUStats() (map[string]string, error) {
	fake.cPUStatsMutex.Lock()
	ret, specificReturn := fake.cPUStatsReturnsOnCall[len(fake.cPUStatsArgsForCall)]
	fake.cPUStatsArgsForCall = append(fake.cPUStatsArgsForCall, struct {
	}{})
	stub := fake.CPUStatsStub
	fakeReturns := fake.cPUStatsReturns
	fake.recordInvocation("CPUStats", []interface{}{})
	fake.cPUStatsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGatherer) CPUStatsCallCount() int {
	fake.cPUStatsMutex.RLock()
	defer fake.cPUStatsMutex.RUnlock()
	return len(fake.cPUStatsArgsForCall)
}

func (fake *FakeGatherer) CPUStatsCalls(stub func() (map[string]string, error)) {
	fake.cPUStatsMutex.Lock()
	defer fake.cPUStatsMutex.Unlock()
	fake.CPUStatsStub = stub
}

func (fake *FakeGatherer) CPUStatsReturns(result1 map[string]string, result2 error) {
	fake.cPUStatsMutex.Lock()
	defer fake.cPUStatsMutex.Unlock()
	fake.CPUStatsStub = nil
	fake.cPUStatsReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) CPUStatsReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.cPUStatsMutex.Lock()
	defer fake.cPUStatsMutex.Unlock()
	fake.CPUStatsStub = nil
	if fake.cPUStatsReturnsOnCall == nil {
		fake.cPUStatsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.cPUStatsReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) DatabaseMetadata() (map[string]string, map[string]string, error) {
	fake.databaseMetadataMutex.Lock()
	ret, specificReturn := fake.databaseMetadataReturnsOnCall[len(fake.databaseMetadataArgsForCall)]
	fake.databaseMetadataArgsForCall = append(fake.databaseMetadataArgsForCall, struct {
	}{})
	stub := fake.DatabaseMetadataStub
	fakeReturns := fake.databaseMetadataReturns
	fake.recordInvocation("DatabaseMetadata", []interface{}{})
	fake.databaseMetadataMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGatherer) DatabaseMetadataCallCount() int {
	fake.databaseMetadataMutex.RLock()
	defer fake.databaseMetadataMutex.RUnlock()
	return len(fake.databaseMetadataArgsForCall)
}

func (fake *FakeGatherer) DatabaseMetadataCalls(stub func() (map[string]string, map[string]string, error)) {
	fake.databaseMetadataMutex.Lock()
	defer fake.databaseMetadataMutex.Unlock()
	fake.DatabaseMetadataStub = stub
}

func (fake *FakeGatherer) DatabaseMetadataReturns(result1 map[string]string, result2 map[string]string, result3 error) {
	fake.databaseMetadataMutex.Lock()
	defer fake.databaseMetadataMutex.Unlock()
	fake.DatabaseMetadataStub = nil
	fake.databaseMetadataReturns = struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGatherer) DatabaseMetadataReturnsOnCall(i int, result1 map[string]string, result2 map[string]string, result3 error) {
	fake.databaseMetadataMutex.Lock()
	defer fake.databaseMetadataMutex.Unlock()
	fake.DatabaseMetadataStub = nil
	if fake.databaseMetadataReturnsOnCall == nil {
		fake.databaseMetadataReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 map[string]string
			result3 error
		})
	}
	fake.databaseMetadataReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGatherer) DiskStats() (map[string]string, error) {
	fake.diskStatsMutex.Lock()
	ret, specificReturn := fake.diskStatsReturnsOnCall[len(fake.diskStatsArgsForCall)]
	fake.diskStatsArgsForCall = append(fake.diskStatsArgsForCall, struct {
	}{})
	stub := fake.DiskStatsStub
	fakeReturns := fake.diskStatsReturns
	fake.recordInvocation("DiskStats", []interface{}{})
	fake.diskStatsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGatherer) DiskStatsCallCount() int {
	fake.diskStatsMutex.RLock()
	defer fake.diskStatsMutex.RUnlock()
	return len(fake.diskStatsArgsForCall)
}

func (fake *FakeGatherer) DiskStatsCalls(stub func() (map[string]string, error)) {
	fake.diskStatsMutex.Lock()
	defer fake.diskStatsMutex.Unlock()
	fake.DiskStatsStub = stub
}

func (fake *FakeGatherer) DiskStatsReturns(result1 map[string]string, result2 error) {
	fake.diskStatsMutex.Lock()
	defer fake.diskStatsMutex.Unlock()
	fake.DiskStatsStub = nil
	fake.diskStatsReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) DiskStatsReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.diskStatsMutex.Lock()
	defer fake.diskStatsMutex.Unlock()
	fake.DiskStatsStub = nil
	if fake.diskStatsReturnsOnCall == nil {
		fake.diskStatsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.diskStatsReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) FindLastBackupTimestamp() (time.Time, error) {
	fake.findLastBackupTimestampMutex.Lock()
	ret, specificReturn := fake.findLastBackupTimestampReturnsOnCall[len(fake.findLastBackupTimestampArgsForCall)]
	fake.findLastBackupTimestampArgsForCall = append(fake.findLastBackupTimestampArgsForCall, struct {
	}{})
	stub := fake.FindLastBackupTimestampStub
	fakeReturns := fake.findLastBackupTimestampReturns
	fake.recordInvocation("FindLastBackupTimestamp", []interface{}{})
	fake.findLastBackupTimestampMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGatherer) FindLastBackupTimestampCallCount() int {
	fake.findLastBackupTimestampMutex.RLock()
	defer fake.findLastBackupTimestampMutex.RUnlock()
	return len(fake.findLastBackupTimestampArgsForCall)
}

func (fake *FakeGatherer) FindLastBackupTimestampCalls(stub func() (time.Time, error)) {
	fake.findLastBackupTimestampMutex.Lock()
	defer fake.findLastBackupTimestampMutex.Unlock()
	fake.FindLastBackupTimestampStub = stub
}

func (fake *FakeGatherer) FindLastBackupTimestampReturns(result1 time.Time, result2 error) {
	fake.findLastBackupTimestampMutex.Lock()
	defer fake.findLastBackupTimestampMutex.Unlock()
	fake.FindLastBackupTimestampStub = nil
	fake.findLastBackupTimestampReturns = struct {
		result1 time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) FindLastBackupTimestampReturnsOnCall(i int, result1 time.Time, result2 error) {
	fake.findLastBackupTimestampMutex.Lock()
	defer fake.findLastBackupTimestampMutex.Unlock()
	fake.FindLastBackupTimestampStub = nil
	if fake.findLastBackupTimestampReturnsOnCall == nil {
		fake.findLastBackupTimestampReturnsOnCall = make(map[int]struct {
			result1 time.Time
			result2 error
		})
	}
	fake.findLastBackupTimestampReturnsOnCall[i] = struct {
		result1 time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) FollowerMetadata() (map[string]string, map[string]string, error) {
	fake.followerMetadataMutex.Lock()
	ret, specificReturn := fake.followerMetadataReturnsOnCall[len(fake.followerMetadataArgsForCall)]
	fake.followerMetadataArgsForCall = append(fake.followerMetadataArgsForCall, struct {
	}{})
	stub := fake.FollowerMetadataStub
	fakeReturns := fake.followerMetadataReturns
	fake.recordInvocation("FollowerMetadata", []interface{}{})
	fake.followerMetadataMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGatherer) FollowerMetadataCallCount() int {
	fake.followerMetadataMutex.RLock()
	defer fake.followerMetadataMutex.RUnlock()
	return len(fake.followerMetadataArgsForCall)
}

func (fake *FakeGatherer) FollowerMetadataCalls(stub func() (map[string]string, map[string]string, error)) {
	fake.followerMetadataMutex.Lock()
	defer fake.followerMetadataMutex.Unlock()
	fake.FollowerMetadataStub = stub
}

func (fake *FakeGatherer) FollowerMetadataReturns(result1 map[string]string, result2 map[string]string, result3 error) {
	fake.followerMetadataMutex.Lock()
	defer fake.followerMetadataMutex.Unlock()
	fake.FollowerMetadataStub = nil
	fake.followerMetadataReturns = struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGatherer) FollowerMetadataReturnsOnCall(i int, result1 map[string]string, result2 map[string]string, result3 error) {
	fake.followerMetadataMutex.Lock()
	defer fake.followerMetadataMutex.Unlock()
	fake.FollowerMetadataStub = nil
	if fake.followerMetadataReturnsOnCall == nil {
		fake.followerMetadataReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 map[string]string
			result3 error
		})
	}
	fake.followerMetadataReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGatherer) IsDatabaseAvailable() bool {
	fake.isDatabaseAvailableMutex.Lock()
	ret, specificReturn := fake.isDatabaseAvailableReturnsOnCall[len(fake.isDatabaseAvailableArgsForCall)]
	fake.isDatabaseAvailableArgsForCall = append(fake.isDatabaseAvailableArgsForCall, struct {
	}{})
	stub := fake.IsDatabaseAvailableStub
	fakeReturns := fake.isDatabaseAvailableReturns
	fake.recordInvocation("IsDatabaseAvailable", []interface{}{})
	fake.isDatabaseAvailableMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGatherer) IsDatabaseAvailableCallCount() int {
	fake.isDatabaseAvailableMutex.RLock()
	defer fake.isDatabaseAvailableMutex.RUnlock()
	return len(fake.isDatabaseAvailableArgsForCall)
}

func (fake *FakeGatherer) IsDatabaseAvailableCalls(stub func() bool) {
	fake.isDatabaseAvailableMutex.Lock()
	defer fake.isDatabaseAvailableMutex.Unlock()
	fake.IsDatabaseAvailableStub = stub
}

func (fake *FakeGatherer) IsDatabaseAvailableReturns(result1 bool) {
	fake.isDatabaseAvailableMutex.Lock()
	defer fake.isDatabaseAvailableMutex.Unlock()
	fake.IsDatabaseAvailableStub = nil
	fake.isDatabaseAvailableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGatherer) IsDatabaseAvailableReturnsOnCall(i int, result1 bool) {
	fake.isDatabaseAvailableMutex.Lock()
	defer fake.isDatabaseAvailableMutex.Unlock()
	fake.IsDatabaseAvailableStub = nil
	if fake.isDatabaseAvailableReturnsOnCall == nil {
		fake.isDatabaseAvailableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isDatabaseAvailableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGatherer) IsDatabaseFollower() (bool, error) {
	fake.isDatabaseFollowerMutex.Lock()
	ret, specificReturn := fake.isDatabaseFollowerReturnsOnCall[len(fake.isDatabaseFollowerArgsForCall)]
	fake.isDatabaseFollowerArgsForCall = append(fake.isDatabaseFollowerArgsForCall, struct {
	}{})
	stub := fake.IsDatabaseFollowerStub
	fakeReturns := fake.isDatabaseFollowerReturns
	fake.recordInvocation("IsDatabaseFollower", []interface{}{})
	fake.isDatabaseFollowerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGatherer) IsDatabaseFollowerCallCount() int {
	fake.isDatabaseFollowerMutex.RLock()
	defer fake.isDatabaseFollowerMutex.RUnlock()
	return len(fake.isDatabaseFollowerArgsForCall)
}

func (fake *FakeGatherer) IsDatabaseFollowerCalls(stub func() (bool, error)) {
	fake.isDatabaseFollowerMutex.Lock()
	defer fake.isDatabaseFollowerMutex.Unlock()
	fake.IsDatabaseFollowerStub = stub
}

func (fake *FakeGatherer) IsDatabaseFollowerReturns(result1 bool, result2 error) {
	fake.isDatabaseFollowerMutex.Lock()
	defer fake.isDatabaseFollowerMutex.Unlock()
	fake.IsDatabaseFollowerStub = nil
	fake.isDatabaseFollowerReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) IsDatabaseFollowerReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isDatabaseFollowerMutex.Lock()
	defer fake.isDatabaseFollowerMutex.Unlock()
	fake.IsDatabaseFollowerStub = nil
	if fake.isDatabaseFollowerReturnsOnCall == nil {
		fake.isDatabaseFollowerReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isDatabaseFollowerReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.brokerStatsMutex.RLock()
	defer fake.brokerStatsMutex.RUnlock()
	fake.cPUStatsMutex.RLock()
	defer fake.cPUStatsMutex.RUnlock()
	fake.databaseMetadataMutex.RLock()
	defer fake.databaseMetadataMutex.RUnlock()
	fake.diskStatsMutex.RLock()
	defer fake.diskStatsMutex.RUnlock()
	fake.findLastBackupTimestampMutex.RLock()
	defer fake.findLastBackupTimestampMutex.RUnlock()
	fake.followerMetadataMutex.RLock()
	defer fake.followerMetadataMutex.RUnlock()
	fake.isDatabaseAvailableMutex.RLock()
	defer fake.isDatabaseAvailableMutex.RUnlock()
	fake.isDatabaseFollowerMutex.RLock()
	defer fake.isDatabaseFollowerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGatherer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ metrics.Gatherer = new(FakeGatherer)
