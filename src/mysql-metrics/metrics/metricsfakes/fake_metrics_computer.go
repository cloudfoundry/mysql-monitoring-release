// Code generated by counterfeiter. DO NOT EDIT.
package metricsfakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry/mysql-metrics/metrics"
)

type FakeMetricsComputer struct {
	ComputeAvailabilityMetricStub        func(bool) *metrics.Metric
	computeAvailabilityMetricMutex       sync.RWMutex
	computeAvailabilityMetricArgsForCall []struct {
		arg1 bool
	}
	computeAvailabilityMetricReturns struct {
		result1 *metrics.Metric
	}
	computeAvailabilityMetricReturnsOnCall map[int]struct {
		result1 *metrics.Metric
	}
	ComputeBackupMetricStub        func(time.Time) *metrics.Metric
	computeBackupMetricMutex       sync.RWMutex
	computeBackupMetricArgsForCall []struct {
		arg1 time.Time
	}
	computeBackupMetricReturns struct {
		result1 *metrics.Metric
	}
	computeBackupMetricReturnsOnCall map[int]struct {
		result1 *metrics.Metric
	}
	ComputeBrokerMetricsStub        func(map[string]string) []*metrics.Metric
	computeBrokerMetricsMutex       sync.RWMutex
	computeBrokerMetricsArgsForCall []struct {
		arg1 map[string]string
	}
	computeBrokerMetricsReturns struct {
		result1 []*metrics.Metric
	}
	computeBrokerMetricsReturnsOnCall map[int]struct {
		result1 []*metrics.Metric
	}
	ComputeCPUMetricsStub        func(map[string]string) []*metrics.Metric
	computeCPUMetricsMutex       sync.RWMutex
	computeCPUMetricsArgsForCall []struct {
		arg1 map[string]string
	}
	computeCPUMetricsReturns struct {
		result1 []*metrics.Metric
	}
	computeCPUMetricsReturnsOnCall map[int]struct {
		result1 []*metrics.Metric
	}
	ComputeDiskMetricsStub        func(map[string]string) []*metrics.Metric
	computeDiskMetricsMutex       sync.RWMutex
	computeDiskMetricsArgsForCall []struct {
		arg1 map[string]string
	}
	computeDiskMetricsReturns struct {
		result1 []*metrics.Metric
	}
	computeDiskMetricsReturnsOnCall map[int]struct {
		result1 []*metrics.Metric
	}
	ComputeGaleraMetricsStub        func(map[string]string) []*metrics.Metric
	computeGaleraMetricsMutex       sync.RWMutex
	computeGaleraMetricsArgsForCall []struct {
		arg1 map[string]string
	}
	computeGaleraMetricsReturns struct {
		result1 []*metrics.Metric
	}
	computeGaleraMetricsReturnsOnCall map[int]struct {
		result1 []*metrics.Metric
	}
	ComputeGlobalMetricsStub        func(map[string]string) []*metrics.Metric
	computeGlobalMetricsMutex       sync.RWMutex
	computeGlobalMetricsArgsForCall []struct {
		arg1 map[string]string
	}
	computeGlobalMetricsReturns struct {
		result1 []*metrics.Metric
	}
	computeGlobalMetricsReturnsOnCall map[int]struct {
		result1 []*metrics.Metric
	}
	ComputeIsFollowerMetricStub        func(bool) *metrics.Metric
	computeIsFollowerMetricMutex       sync.RWMutex
	computeIsFollowerMetricArgsForCall []struct {
		arg1 bool
	}
	computeIsFollowerMetricReturns struct {
		result1 *metrics.Metric
	}
	computeIsFollowerMetricReturnsOnCall map[int]struct {
		result1 *metrics.Metric
	}
	ComputeLeaderFollowerMetricsStub        func(map[string]string) []*metrics.Metric
	computeLeaderFollowerMetricsMutex       sync.RWMutex
	computeLeaderFollowerMetricsArgsForCall []struct {
		arg1 map[string]string
	}
	computeLeaderFollowerMetricsReturns struct {
		result1 []*metrics.Metric
	}
	computeLeaderFollowerMetricsReturnsOnCall map[int]struct {
		result1 []*metrics.Metric
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMetricsComputer) ComputeAvailabilityMetric(arg1 bool) *metrics.Metric {
	fake.computeAvailabilityMetricMutex.Lock()
	ret, specificReturn := fake.computeAvailabilityMetricReturnsOnCall[len(fake.computeAvailabilityMetricArgsForCall)]
	fake.computeAvailabilityMetricArgsForCall = append(fake.computeAvailabilityMetricArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.ComputeAvailabilityMetricStub
	fakeReturns := fake.computeAvailabilityMetricReturns
	fake.recordInvocation("ComputeAvailabilityMetric", []interface{}{arg1})
	fake.computeAvailabilityMetricMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMetricsComputer) ComputeAvailabilityMetricCallCount() int {
	fake.computeAvailabilityMetricMutex.RLock()
	defer fake.computeAvailabilityMetricMutex.RUnlock()
	return len(fake.computeAvailabilityMetricArgsForCall)
}

func (fake *FakeMetricsComputer) ComputeAvailabilityMetricCalls(stub func(bool) *metrics.Metric) {
	fake.computeAvailabilityMetricMutex.Lock()
	defer fake.computeAvailabilityMetricMutex.Unlock()
	fake.ComputeAvailabilityMetricStub = stub
}

func (fake *FakeMetricsComputer) ComputeAvailabilityMetricArgsForCall(i int) bool {
	fake.computeAvailabilityMetricMutex.RLock()
	defer fake.computeAvailabilityMetricMutex.RUnlock()
	argsForCall := fake.computeAvailabilityMetricArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMetricsComputer) ComputeAvailabilityMetricReturns(result1 *metrics.Metric) {
	fake.computeAvailabilityMetricMutex.Lock()
	defer fake.computeAvailabilityMetricMutex.Unlock()
	fake.ComputeAvailabilityMetricStub = nil
	fake.computeAvailabilityMetricReturns = struct {
		result1 *metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeAvailabilityMetricReturnsOnCall(i int, result1 *metrics.Metric) {
	fake.computeAvailabilityMetricMutex.Lock()
	defer fake.computeAvailabilityMetricMutex.Unlock()
	fake.ComputeAvailabilityMetricStub = nil
	if fake.computeAvailabilityMetricReturnsOnCall == nil {
		fake.computeAvailabilityMetricReturnsOnCall = make(map[int]struct {
			result1 *metrics.Metric
		})
	}
	fake.computeAvailabilityMetricReturnsOnCall[i] = struct {
		result1 *metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeBackupMetric(arg1 time.Time) *metrics.Metric {
	fake.computeBackupMetricMutex.Lock()
	ret, specificReturn := fake.computeBackupMetricReturnsOnCall[len(fake.computeBackupMetricArgsForCall)]
	fake.computeBackupMetricArgsForCall = append(fake.computeBackupMetricArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	stub := fake.ComputeBackupMetricStub
	fakeReturns := fake.computeBackupMetricReturns
	fake.recordInvocation("ComputeBackupMetric", []interface{}{arg1})
	fake.computeBackupMetricMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMetricsComputer) ComputeBackupMetricCallCount() int {
	fake.computeBackupMetricMutex.RLock()
	defer fake.computeBackupMetricMutex.RUnlock()
	return len(fake.computeBackupMetricArgsForCall)
}

func (fake *FakeMetricsComputer) ComputeBackupMetricCalls(stub func(time.Time) *metrics.Metric) {
	fake.computeBackupMetricMutex.Lock()
	defer fake.computeBackupMetricMutex.Unlock()
	fake.ComputeBackupMetricStub = stub
}

func (fake *FakeMetricsComputer) ComputeBackupMetricArgsForCall(i int) time.Time {
	fake.computeBackupMetricMutex.RLock()
	defer fake.computeBackupMetricMutex.RUnlock()
	argsForCall := fake.computeBackupMetricArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMetricsComputer) ComputeBackupMetricReturns(result1 *metrics.Metric) {
	fake.computeBackupMetricMutex.Lock()
	defer fake.computeBackupMetricMutex.Unlock()
	fake.ComputeBackupMetricStub = nil
	fake.computeBackupMetricReturns = struct {
		result1 *metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeBackupMetricReturnsOnCall(i int, result1 *metrics.Metric) {
	fake.computeBackupMetricMutex.Lock()
	defer fake.computeBackupMetricMutex.Unlock()
	fake.ComputeBackupMetricStub = nil
	if fake.computeBackupMetricReturnsOnCall == nil {
		fake.computeBackupMetricReturnsOnCall = make(map[int]struct {
			result1 *metrics.Metric
		})
	}
	fake.computeBackupMetricReturnsOnCall[i] = struct {
		result1 *metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeBrokerMetrics(arg1 map[string]string) []*metrics.Metric {
	fake.computeBrokerMetricsMutex.Lock()
	ret, specificReturn := fake.computeBrokerMetricsReturnsOnCall[len(fake.computeBrokerMetricsArgsForCall)]
	fake.computeBrokerMetricsArgsForCall = append(fake.computeBrokerMetricsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.ComputeBrokerMetricsStub
	fakeReturns := fake.computeBrokerMetricsReturns
	fake.recordInvocation("ComputeBrokerMetrics", []interface{}{arg1})
	fake.computeBrokerMetricsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMetricsComputer) ComputeBrokerMetricsCallCount() int {
	fake.computeBrokerMetricsMutex.RLock()
	defer fake.computeBrokerMetricsMutex.RUnlock()
	return len(fake.computeBrokerMetricsArgsForCall)
}

func (fake *FakeMetricsComputer) ComputeBrokerMetricsCalls(stub func(map[string]string) []*metrics.Metric) {
	fake.computeBrokerMetricsMutex.Lock()
	defer fake.computeBrokerMetricsMutex.Unlock()
	fake.ComputeBrokerMetricsStub = stub
}

func (fake *FakeMetricsComputer) ComputeBrokerMetricsArgsForCall(i int) map[string]string {
	fake.computeBrokerMetricsMutex.RLock()
	defer fake.computeBrokerMetricsMutex.RUnlock()
	argsForCall := fake.computeBrokerMetricsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMetricsComputer) ComputeBrokerMetricsReturns(result1 []*metrics.Metric) {
	fake.computeBrokerMetricsMutex.Lock()
	defer fake.computeBrokerMetricsMutex.Unlock()
	fake.ComputeBrokerMetricsStub = nil
	fake.computeBrokerMetricsReturns = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeBrokerMetricsReturnsOnCall(i int, result1 []*metrics.Metric) {
	fake.computeBrokerMetricsMutex.Lock()
	defer fake.computeBrokerMetricsMutex.Unlock()
	fake.ComputeBrokerMetricsStub = nil
	if fake.computeBrokerMetricsReturnsOnCall == nil {
		fake.computeBrokerMetricsReturnsOnCall = make(map[int]struct {
			result1 []*metrics.Metric
		})
	}
	fake.computeBrokerMetricsReturnsOnCall[i] = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeCPUMetrics(arg1 map[string]string) []*metrics.Metric {
	fake.computeCPUMetricsMutex.Lock()
	ret, specificReturn := fake.computeCPUMetricsReturnsOnCall[len(fake.computeCPUMetricsArgsForCall)]
	fake.computeCPUMetricsArgsForCall = append(fake.computeCPUMetricsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.ComputeCPUMetricsStub
	fakeReturns := fake.computeCPUMetricsReturns
	fake.recordInvocation("ComputeCPUMetrics", []interface{}{arg1})
	fake.computeCPUMetricsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMetricsComputer) ComputeCPUMetricsCallCount() int {
	fake.computeCPUMetricsMutex.RLock()
	defer fake.computeCPUMetricsMutex.RUnlock()
	return len(fake.computeCPUMetricsArgsForCall)
}

func (fake *FakeMetricsComputer) ComputeCPUMetricsCalls(stub func(map[string]string) []*metrics.Metric) {
	fake.computeCPUMetricsMutex.Lock()
	defer fake.computeCPUMetricsMutex.Unlock()
	fake.ComputeCPUMetricsStub = stub
}

func (fake *FakeMetricsComputer) ComputeCPUMetricsArgsForCall(i int) map[string]string {
	fake.computeCPUMetricsMutex.RLock()
	defer fake.computeCPUMetricsMutex.RUnlock()
	argsForCall := fake.computeCPUMetricsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMetricsComputer) ComputeCPUMetricsReturns(result1 []*metrics.Metric) {
	fake.computeCPUMetricsMutex.Lock()
	defer fake.computeCPUMetricsMutex.Unlock()
	fake.ComputeCPUMetricsStub = nil
	fake.computeCPUMetricsReturns = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeCPUMetricsReturnsOnCall(i int, result1 []*metrics.Metric) {
	fake.computeCPUMetricsMutex.Lock()
	defer fake.computeCPUMetricsMutex.Unlock()
	fake.ComputeCPUMetricsStub = nil
	if fake.computeCPUMetricsReturnsOnCall == nil {
		fake.computeCPUMetricsReturnsOnCall = make(map[int]struct {
			result1 []*metrics.Metric
		})
	}
	fake.computeCPUMetricsReturnsOnCall[i] = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeDiskMetrics(arg1 map[string]string) []*metrics.Metric {
	fake.computeDiskMetricsMutex.Lock()
	ret, specificReturn := fake.computeDiskMetricsReturnsOnCall[len(fake.computeDiskMetricsArgsForCall)]
	fake.computeDiskMetricsArgsForCall = append(fake.computeDiskMetricsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.ComputeDiskMetricsStub
	fakeReturns := fake.computeDiskMetricsReturns
	fake.recordInvocation("ComputeDiskMetrics", []interface{}{arg1})
	fake.computeDiskMetricsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMetricsComputer) ComputeDiskMetricsCallCount() int {
	fake.computeDiskMetricsMutex.RLock()
	defer fake.computeDiskMetricsMutex.RUnlock()
	return len(fake.computeDiskMetricsArgsForCall)
}

func (fake *FakeMetricsComputer) ComputeDiskMetricsCalls(stub func(map[string]string) []*metrics.Metric) {
	fake.computeDiskMetricsMutex.Lock()
	defer fake.computeDiskMetricsMutex.Unlock()
	fake.ComputeDiskMetricsStub = stub
}

func (fake *FakeMetricsComputer) ComputeDiskMetricsArgsForCall(i int) map[string]string {
	fake.computeDiskMetricsMutex.RLock()
	defer fake.computeDiskMetricsMutex.RUnlock()
	argsForCall := fake.computeDiskMetricsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMetricsComputer) ComputeDiskMetricsReturns(result1 []*metrics.Metric) {
	fake.computeDiskMetricsMutex.Lock()
	defer fake.computeDiskMetricsMutex.Unlock()
	fake.ComputeDiskMetricsStub = nil
	fake.computeDiskMetricsReturns = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeDiskMetricsReturnsOnCall(i int, result1 []*metrics.Metric) {
	fake.computeDiskMetricsMutex.Lock()
	defer fake.computeDiskMetricsMutex.Unlock()
	fake.ComputeDiskMetricsStub = nil
	if fake.computeDiskMetricsReturnsOnCall == nil {
		fake.computeDiskMetricsReturnsOnCall = make(map[int]struct {
			result1 []*metrics.Metric
		})
	}
	fake.computeDiskMetricsReturnsOnCall[i] = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeGaleraMetrics(arg1 map[string]string) []*metrics.Metric {
	fake.computeGaleraMetricsMutex.Lock()
	ret, specificReturn := fake.computeGaleraMetricsReturnsOnCall[len(fake.computeGaleraMetricsArgsForCall)]
	fake.computeGaleraMetricsArgsForCall = append(fake.computeGaleraMetricsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.ComputeGaleraMetricsStub
	fakeReturns := fake.computeGaleraMetricsReturns
	fake.recordInvocation("ComputeGaleraMetrics", []interface{}{arg1})
	fake.computeGaleraMetricsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMetricsComputer) ComputeGaleraMetricsCallCount() int {
	fake.computeGaleraMetricsMutex.RLock()
	defer fake.computeGaleraMetricsMutex.RUnlock()
	return len(fake.computeGaleraMetricsArgsForCall)
}

func (fake *FakeMetricsComputer) ComputeGaleraMetricsCalls(stub func(map[string]string) []*metrics.Metric) {
	fake.computeGaleraMetricsMutex.Lock()
	defer fake.computeGaleraMetricsMutex.Unlock()
	fake.ComputeGaleraMetricsStub = stub
}

func (fake *FakeMetricsComputer) ComputeGaleraMetricsArgsForCall(i int) map[string]string {
	fake.computeGaleraMetricsMutex.RLock()
	defer fake.computeGaleraMetricsMutex.RUnlock()
	argsForCall := fake.computeGaleraMetricsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMetricsComputer) ComputeGaleraMetricsReturns(result1 []*metrics.Metric) {
	fake.computeGaleraMetricsMutex.Lock()
	defer fake.computeGaleraMetricsMutex.Unlock()
	fake.ComputeGaleraMetricsStub = nil
	fake.computeGaleraMetricsReturns = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeGaleraMetricsReturnsOnCall(i int, result1 []*metrics.Metric) {
	fake.computeGaleraMetricsMutex.Lock()
	defer fake.computeGaleraMetricsMutex.Unlock()
	fake.ComputeGaleraMetricsStub = nil
	if fake.computeGaleraMetricsReturnsOnCall == nil {
		fake.computeGaleraMetricsReturnsOnCall = make(map[int]struct {
			result1 []*metrics.Metric
		})
	}
	fake.computeGaleraMetricsReturnsOnCall[i] = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeGlobalMetrics(arg1 map[string]string) []*metrics.Metric {
	fake.computeGlobalMetricsMutex.Lock()
	ret, specificReturn := fake.computeGlobalMetricsReturnsOnCall[len(fake.computeGlobalMetricsArgsForCall)]
	fake.computeGlobalMetricsArgsForCall = append(fake.computeGlobalMetricsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.ComputeGlobalMetricsStub
	fakeReturns := fake.computeGlobalMetricsReturns
	fake.recordInvocation("ComputeGlobalMetrics", []interface{}{arg1})
	fake.computeGlobalMetricsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMetricsComputer) ComputeGlobalMetricsCallCount() int {
	fake.computeGlobalMetricsMutex.RLock()
	defer fake.computeGlobalMetricsMutex.RUnlock()
	return len(fake.computeGlobalMetricsArgsForCall)
}

func (fake *FakeMetricsComputer) ComputeGlobalMetricsCalls(stub func(map[string]string) []*metrics.Metric) {
	fake.computeGlobalMetricsMutex.Lock()
	defer fake.computeGlobalMetricsMutex.Unlock()
	fake.ComputeGlobalMetricsStub = stub
}

func (fake *FakeMetricsComputer) ComputeGlobalMetricsArgsForCall(i int) map[string]string {
	fake.computeGlobalMetricsMutex.RLock()
	defer fake.computeGlobalMetricsMutex.RUnlock()
	argsForCall := fake.computeGlobalMetricsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMetricsComputer) ComputeGlobalMetricsReturns(result1 []*metrics.Metric) {
	fake.computeGlobalMetricsMutex.Lock()
	defer fake.computeGlobalMetricsMutex.Unlock()
	fake.ComputeGlobalMetricsStub = nil
	fake.computeGlobalMetricsReturns = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeGlobalMetricsReturnsOnCall(i int, result1 []*metrics.Metric) {
	fake.computeGlobalMetricsMutex.Lock()
	defer fake.computeGlobalMetricsMutex.Unlock()
	fake.ComputeGlobalMetricsStub = nil
	if fake.computeGlobalMetricsReturnsOnCall == nil {
		fake.computeGlobalMetricsReturnsOnCall = make(map[int]struct {
			result1 []*metrics.Metric
		})
	}
	fake.computeGlobalMetricsReturnsOnCall[i] = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeIsFollowerMetric(arg1 bool) *metrics.Metric {
	fake.computeIsFollowerMetricMutex.Lock()
	ret, specificReturn := fake.computeIsFollowerMetricReturnsOnCall[len(fake.computeIsFollowerMetricArgsForCall)]
	fake.computeIsFollowerMetricArgsForCall = append(fake.computeIsFollowerMetricArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.ComputeIsFollowerMetricStub
	fakeReturns := fake.computeIsFollowerMetricReturns
	fake.recordInvocation("ComputeIsFollowerMetric", []interface{}{arg1})
	fake.computeIsFollowerMetricMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMetricsComputer) ComputeIsFollowerMetricCallCount() int {
	fake.computeIsFollowerMetricMutex.RLock()
	defer fake.computeIsFollowerMetricMutex.RUnlock()
	return len(fake.computeIsFollowerMetricArgsForCall)
}

func (fake *FakeMetricsComputer) ComputeIsFollowerMetricCalls(stub func(bool) *metrics.Metric) {
	fake.computeIsFollowerMetricMutex.Lock()
	defer fake.computeIsFollowerMetricMutex.Unlock()
	fake.ComputeIsFollowerMetricStub = stub
}

func (fake *FakeMetricsComputer) ComputeIsFollowerMetricArgsForCall(i int) bool {
	fake.computeIsFollowerMetricMutex.RLock()
	defer fake.computeIsFollowerMetricMutex.RUnlock()
	argsForCall := fake.computeIsFollowerMetricArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMetricsComputer) ComputeIsFollowerMetricReturns(result1 *metrics.Metric) {
	fake.computeIsFollowerMetricMutex.Lock()
	defer fake.computeIsFollowerMetricMutex.Unlock()
	fake.ComputeIsFollowerMetricStub = nil
	fake.computeIsFollowerMetricReturns = struct {
		result1 *metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeIsFollowerMetricReturnsOnCall(i int, result1 *metrics.Metric) {
	fake.computeIsFollowerMetricMutex.Lock()
	defer fake.computeIsFollowerMetricMutex.Unlock()
	fake.ComputeIsFollowerMetricStub = nil
	if fake.computeIsFollowerMetricReturnsOnCall == nil {
		fake.computeIsFollowerMetricReturnsOnCall = make(map[int]struct {
			result1 *metrics.Metric
		})
	}
	fake.computeIsFollowerMetricReturnsOnCall[i] = struct {
		result1 *metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeLeaderFollowerMetrics(arg1 map[string]string) []*metrics.Metric {
	fake.computeLeaderFollowerMetricsMutex.Lock()
	ret, specificReturn := fake.computeLeaderFollowerMetricsReturnsOnCall[len(fake.computeLeaderFollowerMetricsArgsForCall)]
	fake.computeLeaderFollowerMetricsArgsForCall = append(fake.computeLeaderFollowerMetricsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.ComputeLeaderFollowerMetricsStub
	fakeReturns := fake.computeLeaderFollowerMetricsReturns
	fake.recordInvocation("ComputeLeaderFollowerMetrics", []interface{}{arg1})
	fake.computeLeaderFollowerMetricsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMetricsComputer) ComputeLeaderFollowerMetricsCallCount() int {
	fake.computeLeaderFollowerMetricsMutex.RLock()
	defer fake.computeLeaderFollowerMetricsMutex.RUnlock()
	return len(fake.computeLeaderFollowerMetricsArgsForCall)
}

func (fake *FakeMetricsComputer) ComputeLeaderFollowerMetricsCalls(stub func(map[string]string) []*metrics.Metric) {
	fake.computeLeaderFollowerMetricsMutex.Lock()
	defer fake.computeLeaderFollowerMetricsMutex.Unlock()
	fake.ComputeLeaderFollowerMetricsStub = stub
}

func (fake *FakeMetricsComputer) ComputeLeaderFollowerMetricsArgsForCall(i int) map[string]string {
	fake.computeLeaderFollowerMetricsMutex.RLock()
	defer fake.computeLeaderFollowerMetricsMutex.RUnlock()
	argsForCall := fake.computeLeaderFollowerMetricsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMetricsComputer) ComputeLeaderFollowerMetricsReturns(result1 []*metrics.Metric) {
	fake.computeLeaderFollowerMetricsMutex.Lock()
	defer fake.computeLeaderFollowerMetricsMutex.Unlock()
	fake.ComputeLeaderFollowerMetricsStub = nil
	fake.computeLeaderFollowerMetricsReturns = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) ComputeLeaderFollowerMetricsReturnsOnCall(i int, result1 []*metrics.Metric) {
	fake.computeLeaderFollowerMetricsMutex.Lock()
	defer fake.computeLeaderFollowerMetricsMutex.Unlock()
	fake.ComputeLeaderFollowerMetricsStub = nil
	if fake.computeLeaderFollowerMetricsReturnsOnCall == nil {
		fake.computeLeaderFollowerMetricsReturnsOnCall = make(map[int]struct {
			result1 []*metrics.Metric
		})
	}
	fake.computeLeaderFollowerMetricsReturnsOnCall[i] = struct {
		result1 []*metrics.Metric
	}{result1}
}

func (fake *FakeMetricsComputer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.computeAvailabilityMetricMutex.RLock()
	defer fake.computeAvailabilityMetricMutex.RUnlock()
	fake.computeBackupMetricMutex.RLock()
	defer fake.computeBackupMetricMutex.RUnlock()
	fake.computeBrokerMetricsMutex.RLock()
	defer fake.computeBrokerMetricsMutex.RUnlock()
	fake.computeCPUMetricsMutex.RLock()
	defer fake.computeCPUMetricsMutex.RUnlock()
	fake.computeDiskMetricsMutex.RLock()
	defer fake.computeDiskMetricsMutex.RUnlock()
	fake.computeGaleraMetricsMutex.RLock()
	defer fake.computeGaleraMetricsMutex.RUnlock()
	fake.computeGlobalMetricsMutex.RLock()
	defer fake.computeGlobalMetricsMutex.RUnlock()
	fake.computeIsFollowerMetricMutex.RLock()
	defer fake.computeIsFollowerMetricMutex.RUnlock()
	fake.computeLeaderFollowerMetricsMutex.RLock()
	defer fake.computeLeaderFollowerMetricsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMetricsComputer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ metrics.MetricsComputer = new(FakeMetricsComputer)
