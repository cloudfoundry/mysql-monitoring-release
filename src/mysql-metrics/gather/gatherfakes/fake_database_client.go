// Code generated by counterfeiter. DO NOT EDIT.
package gatherfakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry/mysql-metrics/gather"
)

type FakeDatabaseClient struct {
	FindLastBackupTimestampStub        func() (time.Time, error)
	findLastBackupTimestampMutex       sync.RWMutex
	findLastBackupTimestampArgsForCall []struct {
	}
	findLastBackupTimestampReturns struct {
		result1 time.Time
		result2 error
	}
	findLastBackupTimestampReturnsOnCall map[int]struct {
		result1 time.Time
		result2 error
	}
	HeartbeatStatusStub        func() (map[string]string, error)
	heartbeatStatusMutex       sync.RWMutex
	heartbeatStatusArgsForCall []struct {
	}
	heartbeatStatusReturns struct {
		result1 map[string]string
		result2 error
	}
	heartbeatStatusReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	IsAvailableStub        func() bool
	isAvailableMutex       sync.RWMutex
	isAvailableArgsForCall []struct {
	}
	isAvailableReturns struct {
		result1 bool
	}
	isAvailableReturnsOnCall map[int]struct {
		result1 bool
	}
	IsFollowerStub        func() (bool, error)
	isFollowerMutex       sync.RWMutex
	isFollowerArgsForCall []struct {
	}
	isFollowerReturns struct {
		result1 bool
		result2 error
	}
	isFollowerReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ServicePlansDiskAllocatedStub        func() (map[string]string, error)
	servicePlansDiskAllocatedMutex       sync.RWMutex
	servicePlansDiskAllocatedArgsForCall []struct {
	}
	servicePlansDiskAllocatedReturns struct {
		result1 map[string]string
		result2 error
	}
	servicePlansDiskAllocatedReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	ShowGlobalStatusStub        func() (map[string]string, error)
	showGlobalStatusMutex       sync.RWMutex
	showGlobalStatusArgsForCall []struct {
	}
	showGlobalStatusReturns struct {
		result1 map[string]string
		result2 error
	}
	showGlobalStatusReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	ShowGlobalVariablesStub        func() (map[string]string, error)
	showGlobalVariablesMutex       sync.RWMutex
	showGlobalVariablesArgsForCall []struct {
	}
	showGlobalVariablesReturns struct {
		result1 map[string]string
		result2 error
	}
	showGlobalVariablesReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	ShowSlaveStatusStub        func() (map[string]string, error)
	showSlaveStatusMutex       sync.RWMutex
	showSlaveStatusArgsForCall []struct {
	}
	showSlaveStatusReturns struct {
		result1 map[string]string
		result2 error
	}
	showSlaveStatusReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDatabaseClient) FindLastBackupTimestamp() (time.Time, error) {
	fake.findLastBackupTimestampMutex.Lock()
	ret, specificReturn := fake.findLastBackupTimestampReturnsOnCall[len(fake.findLastBackupTimestampArgsForCall)]
	fake.findLastBackupTimestampArgsForCall = append(fake.findLastBackupTimestampArgsForCall, struct {
	}{})
	stub := fake.FindLastBackupTimestampStub
	fakeReturns := fake.findLastBackupTimestampReturns
	fake.recordInvocation("FindLastBackupTimestamp", []interface{}{})
	fake.findLastBackupTimestampMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseClient) FindLastBackupTimestampCallCount() int {
	fake.findLastBackupTimestampMutex.RLock()
	defer fake.findLastBackupTimestampMutex.RUnlock()
	return len(fake.findLastBackupTimestampArgsForCall)
}

func (fake *FakeDatabaseClient) FindLastBackupTimestampCalls(stub func() (time.Time, error)) {
	fake.findLastBackupTimestampMutex.Lock()
	defer fake.findLastBackupTimestampMutex.Unlock()
	fake.FindLastBackupTimestampStub = stub
}

func (fake *FakeDatabaseClient) FindLastBackupTimestampReturns(result1 time.Time, result2 error) {
	fake.findLastBackupTimestampMutex.Lock()
	defer fake.findLastBackupTimestampMutex.Unlock()
	fake.FindLastBackupTimestampStub = nil
	fake.findLastBackupTimestampReturns = struct {
		result1 time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) FindLastBackupTimestampReturnsOnCall(i int, result1 time.Time, result2 error) {
	fake.findLastBackupTimestampMutex.Lock()
	defer fake.findLastBackupTimestampMutex.Unlock()
	fake.FindLastBackupTimestampStub = nil
	if fake.findLastBackupTimestampReturnsOnCall == nil {
		fake.findLastBackupTimestampReturnsOnCall = make(map[int]struct {
			result1 time.Time
			result2 error
		})
	}
	fake.findLastBackupTimestampReturnsOnCall[i] = struct {
		result1 time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) HeartbeatStatus() (map[string]string, error) {
	fake.heartbeatStatusMutex.Lock()
	ret, specificReturn := fake.heartbeatStatusReturnsOnCall[len(fake.heartbeatStatusArgsForCall)]
	fake.heartbeatStatusArgsForCall = append(fake.heartbeatStatusArgsForCall, struct {
	}{})
	stub := fake.HeartbeatStatusStub
	fakeReturns := fake.heartbeatStatusReturns
	fake.recordInvocation("HeartbeatStatus", []interface{}{})
	fake.heartbeatStatusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseClient) HeartbeatStatusCallCount() int {
	fake.heartbeatStatusMutex.RLock()
	defer fake.heartbeatStatusMutex.RUnlock()
	return len(fake.heartbeatStatusArgsForCall)
}

func (fake *FakeDatabaseClient) HeartbeatStatusCalls(stub func() (map[string]string, error)) {
	fake.heartbeatStatusMutex.Lock()
	defer fake.heartbeatStatusMutex.Unlock()
	fake.HeartbeatStatusStub = stub
}

func (fake *FakeDatabaseClient) HeartbeatStatusReturns(result1 map[string]string, result2 error) {
	fake.heartbeatStatusMutex.Lock()
	defer fake.heartbeatStatusMutex.Unlock()
	fake.HeartbeatStatusStub = nil
	fake.heartbeatStatusReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) HeartbeatStatusReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.heartbeatStatusMutex.Lock()
	defer fake.heartbeatStatusMutex.Unlock()
	fake.HeartbeatStatusStub = nil
	if fake.heartbeatStatusReturnsOnCall == nil {
		fake.heartbeatStatusReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.heartbeatStatusReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) IsAvailable() bool {
	fake.isAvailableMutex.Lock()
	ret, specificReturn := fake.isAvailableReturnsOnCall[len(fake.isAvailableArgsForCall)]
	fake.isAvailableArgsForCall = append(fake.isAvailableArgsForCall, struct {
	}{})
	stub := fake.IsAvailableStub
	fakeReturns := fake.isAvailableReturns
	fake.recordInvocation("IsAvailable", []interface{}{})
	fake.isAvailableMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabaseClient) IsAvailableCallCount() int {
	fake.isAvailableMutex.RLock()
	defer fake.isAvailableMutex.RUnlock()
	return len(fake.isAvailableArgsForCall)
}

func (fake *FakeDatabaseClient) IsAvailableCalls(stub func() bool) {
	fake.isAvailableMutex.Lock()
	defer fake.isAvailableMutex.Unlock()
	fake.IsAvailableStub = stub
}

func (fake *FakeDatabaseClient) IsAvailableReturns(result1 bool) {
	fake.isAvailableMutex.Lock()
	defer fake.isAvailableMutex.Unlock()
	fake.IsAvailableStub = nil
	fake.isAvailableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDatabaseClient) IsAvailableReturnsOnCall(i int, result1 bool) {
	fake.isAvailableMutex.Lock()
	defer fake.isAvailableMutex.Unlock()
	fake.IsAvailableStub = nil
	if fake.isAvailableReturnsOnCall == nil {
		fake.isAvailableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isAvailableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDatabaseClient) IsFollower() (bool, error) {
	fake.isFollowerMutex.Lock()
	ret, specificReturn := fake.isFollowerReturnsOnCall[len(fake.isFollowerArgsForCall)]
	fake.isFollowerArgsForCall = append(fake.isFollowerArgsForCall, struct {
	}{})
	stub := fake.IsFollowerStub
	fakeReturns := fake.isFollowerReturns
	fake.recordInvocation("IsFollower", []interface{}{})
	fake.isFollowerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseClient) IsFollowerCallCount() int {
	fake.isFollowerMutex.RLock()
	defer fake.isFollowerMutex.RUnlock()
	return len(fake.isFollowerArgsForCall)
}

func (fake *FakeDatabaseClient) IsFollowerCalls(stub func() (bool, error)) {
	fake.isFollowerMutex.Lock()
	defer fake.isFollowerMutex.Unlock()
	fake.IsFollowerStub = stub
}

func (fake *FakeDatabaseClient) IsFollowerReturns(result1 bool, result2 error) {
	fake.isFollowerMutex.Lock()
	defer fake.isFollowerMutex.Unlock()
	fake.IsFollowerStub = nil
	fake.isFollowerReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) IsFollowerReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isFollowerMutex.Lock()
	defer fake.isFollowerMutex.Unlock()
	fake.IsFollowerStub = nil
	if fake.isFollowerReturnsOnCall == nil {
		fake.isFollowerReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isFollowerReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) ServicePlansDiskAllocated() (map[string]string, error) {
	fake.servicePlansDiskAllocatedMutex.Lock()
	ret, specificReturn := fake.servicePlansDiskAllocatedReturnsOnCall[len(fake.servicePlansDiskAllocatedArgsForCall)]
	fake.servicePlansDiskAllocatedArgsForCall = append(fake.servicePlansDiskAllocatedArgsForCall, struct {
	}{})
	stub := fake.ServicePlansDiskAllocatedStub
	fakeReturns := fake.servicePlansDiskAllocatedReturns
	fake.recordInvocation("ServicePlansDiskAllocated", []interface{}{})
	fake.servicePlansDiskAllocatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseClient) ServicePlansDiskAllocatedCallCount() int {
	fake.servicePlansDiskAllocatedMutex.RLock()
	defer fake.servicePlansDiskAllocatedMutex.RUnlock()
	return len(fake.servicePlansDiskAllocatedArgsForCall)
}

func (fake *FakeDatabaseClient) ServicePlansDiskAllocatedCalls(stub func() (map[string]string, error)) {
	fake.servicePlansDiskAllocatedMutex.Lock()
	defer fake.servicePlansDiskAllocatedMutex.Unlock()
	fake.ServicePlansDiskAllocatedStub = stub
}

func (fake *FakeDatabaseClient) ServicePlansDiskAllocatedReturns(result1 map[string]string, result2 error) {
	fake.servicePlansDiskAllocatedMutex.Lock()
	defer fake.servicePlansDiskAllocatedMutex.Unlock()
	fake.ServicePlansDiskAllocatedStub = nil
	fake.servicePlansDiskAllocatedReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) ServicePlansDiskAllocatedReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.servicePlansDiskAllocatedMutex.Lock()
	defer fake.servicePlansDiskAllocatedMutex.Unlock()
	fake.ServicePlansDiskAllocatedStub = nil
	if fake.servicePlansDiskAllocatedReturnsOnCall == nil {
		fake.servicePlansDiskAllocatedReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.servicePlansDiskAllocatedReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) ShowGlobalStatus() (map[string]string, error) {
	fake.showGlobalStatusMutex.Lock()
	ret, specificReturn := fake.showGlobalStatusReturnsOnCall[len(fake.showGlobalStatusArgsForCall)]
	fake.showGlobalStatusArgsForCall = append(fake.showGlobalStatusArgsForCall, struct {
	}{})
	stub := fake.ShowGlobalStatusStub
	fakeReturns := fake.showGlobalStatusReturns
	fake.recordInvocation("ShowGlobalStatus", []interface{}{})
	fake.showGlobalStatusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseClient) ShowGlobalStatusCallCount() int {
	fake.showGlobalStatusMutex.RLock()
	defer fake.showGlobalStatusMutex.RUnlock()
	return len(fake.showGlobalStatusArgsForCall)
}

func (fake *FakeDatabaseClient) ShowGlobalStatusCalls(stub func() (map[string]string, error)) {
	fake.showGlobalStatusMutex.Lock()
	defer fake.showGlobalStatusMutex.Unlock()
	fake.ShowGlobalStatusStub = stub
}

func (fake *FakeDatabaseClient) ShowGlobalStatusReturns(result1 map[string]string, result2 error) {
	fake.showGlobalStatusMutex.Lock()
	defer fake.showGlobalStatusMutex.Unlock()
	fake.ShowGlobalStatusStub = nil
	fake.showGlobalStatusReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) ShowGlobalStatusReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.showGlobalStatusMutex.Lock()
	defer fake.showGlobalStatusMutex.Unlock()
	fake.ShowGlobalStatusStub = nil
	if fake.showGlobalStatusReturnsOnCall == nil {
		fake.showGlobalStatusReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.showGlobalStatusReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) ShowGlobalVariables() (map[string]string, error) {
	fake.showGlobalVariablesMutex.Lock()
	ret, specificReturn := fake.showGlobalVariablesReturnsOnCall[len(fake.showGlobalVariablesArgsForCall)]
	fake.showGlobalVariablesArgsForCall = append(fake.showGlobalVariablesArgsForCall, struct {
	}{})
	stub := fake.ShowGlobalVariablesStub
	fakeReturns := fake.showGlobalVariablesReturns
	fake.recordInvocation("ShowGlobalVariables", []interface{}{})
	fake.showGlobalVariablesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseClient) ShowGlobalVariablesCallCount() int {
	fake.showGlobalVariablesMutex.RLock()
	defer fake.showGlobalVariablesMutex.RUnlock()
	return len(fake.showGlobalVariablesArgsForCall)
}

func (fake *FakeDatabaseClient) ShowGlobalVariablesCalls(stub func() (map[string]string, error)) {
	fake.showGlobalVariablesMutex.Lock()
	defer fake.showGlobalVariablesMutex.Unlock()
	fake.ShowGlobalVariablesStub = stub
}

func (fake *FakeDatabaseClient) ShowGlobalVariablesReturns(result1 map[string]string, result2 error) {
	fake.showGlobalVariablesMutex.Lock()
	defer fake.showGlobalVariablesMutex.Unlock()
	fake.ShowGlobalVariablesStub = nil
	fake.showGlobalVariablesReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) ShowGlobalVariablesReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.showGlobalVariablesMutex.Lock()
	defer fake.showGlobalVariablesMutex.Unlock()
	fake.ShowGlobalVariablesStub = nil
	if fake.showGlobalVariablesReturnsOnCall == nil {
		fake.showGlobalVariablesReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.showGlobalVariablesReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) ShowSlaveStatus() (map[string]string, error) {
	fake.showSlaveStatusMutex.Lock()
	ret, specificReturn := fake.showSlaveStatusReturnsOnCall[len(fake.showSlaveStatusArgsForCall)]
	fake.showSlaveStatusArgsForCall = append(fake.showSlaveStatusArgsForCall, struct {
	}{})
	stub := fake.ShowSlaveStatusStub
	fakeReturns := fake.showSlaveStatusReturns
	fake.recordInvocation("ShowSlaveStatus", []interface{}{})
	fake.showSlaveStatusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseClient) ShowSlaveStatusCallCount() int {
	fake.showSlaveStatusMutex.RLock()
	defer fake.showSlaveStatusMutex.RUnlock()
	return len(fake.showSlaveStatusArgsForCall)
}

func (fake *FakeDatabaseClient) ShowSlaveStatusCalls(stub func() (map[string]string, error)) {
	fake.showSlaveStatusMutex.Lock()
	defer fake.showSlaveStatusMutex.Unlock()
	fake.ShowSlaveStatusStub = stub
}

func (fake *FakeDatabaseClient) ShowSlaveStatusReturns(result1 map[string]string, result2 error) {
	fake.showSlaveStatusMutex.Lock()
	defer fake.showSlaveStatusMutex.Unlock()
	fake.ShowSlaveStatusStub = nil
	fake.showSlaveStatusReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) ShowSlaveStatusReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.showSlaveStatusMutex.Lock()
	defer fake.showSlaveStatusMutex.Unlock()
	fake.ShowSlaveStatusStub = nil
	if fake.showSlaveStatusReturnsOnCall == nil {
		fake.showSlaveStatusReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.showSlaveStatusReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findLastBackupTimestampMutex.RLock()
	defer fake.findLastBackupTimestampMutex.RUnlock()
	fake.heartbeatStatusMutex.RLock()
	defer fake.heartbeatStatusMutex.RUnlock()
	fake.isAvailableMutex.RLock()
	defer fake.isAvailableMutex.RUnlock()
	fake.isFollowerMutex.RLock()
	defer fake.isFollowerMutex.RUnlock()
	fake.servicePlansDiskAllocatedMutex.RLock()
	defer fake.servicePlansDiskAllocatedMutex.RUnlock()
	fake.showGlobalStatusMutex.RLock()
	defer fake.showGlobalStatusMutex.RUnlock()
	fake.showGlobalVariablesMutex.RLock()
	defer fake.showGlobalVariablesMutex.RUnlock()
	fake.showSlaveStatusMutex.RLock()
	defer fake.showSlaveStatusMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDatabaseClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ gather.DatabaseClient = new(FakeDatabaseClient)
